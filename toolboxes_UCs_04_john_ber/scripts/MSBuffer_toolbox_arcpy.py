#---------------------------------------------------------------------------------------
"""
 MSbuffer - MultiScale Buffer Analysis

 Bruno P. Leles - brunopleles@gmail.com
 John W. Ribeiro - jw.ribeiro.rc@gmail.com
 Juliana Silviera dos Santos - 
 Camila Eboli - 
 Alice C. Hughes - 
 Bernardo B. S. Niebuhr - bernardo_brandaum@yahoo.com.br
 Milton C. Ribeiro - mcr@rc.unesp.br

 Universidade Estadual Paulista - UNESP
 Rio Claro - SP - Brasil

 This script runs inside ArcMap v???? using Python shell.
 Usage: ????

 Short description

 Copyright (C) 2017 by Bruno P. Leles, John W. Ribeiro, and Milton C. Ribeiro.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 2 of the license, 
 or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program. If not, see <http://www.gnu.org/licenses/>.
"""
#---------------------------------------------------------------------------------------


# Import modules 
import arcpy
from arcpy import env
import os, sys
import arcpy.mapping

# Name of the geo database where output buffer maps will be saved
geoDB_name = "output_buffer_maps.gdb"
# Do we want to overwrite output buffer maps in case the analysis is re-run?
overwrite_maps = True


# Reading parameters from the GUI
# Input map
UCs=arcpy.GetParameterAsText(0) # inputmap ao inves de UCs
inputCol=arcpy.GetParameterAsText(1)
inputmap_name=UCs.split("\\")
inputmap_name=inputmap_name[-1].replace(".shp",'') # name of the input map (without the path)

# Input variable of interest
variable_interest=arcpy.GetParameterAsText(2) # map of the variable of interest

# Scale (buffer size in meters)
escale=arcpy.GetParameterAsText(3)
escale=int(escale)

########## MUDAR NOME
# Multiplier field (number of buffers) 
mult=arcpy.GetParameterAsText(4)
mult=int(mult)

# Should we count the number of features?
count_on_off=arcpy.GetParameterAsText(5)
feature_to_count = variable_interest
#feature_to_count=arcpy.GetParameterAsText(6) # campo de texto - talvez nao vamos precisar disso


######## mudar para ser prefixo
# Prefix for output files 
OutPutTxt=arcpy.GetParameterAsText(7)

# DEFINIR NOMES DOS OUTPUTS
# prefix_area.txt
# prefix_count, functionalarea
# DEFINIR NOMES DOS OUTPUT MAPS (GEODB)

# Folder for output files
OutPutFolder=arcpy.GetParameterAsText(8)

# PODEMOS TESTAR SE OS PARAMETROS ESTAO OK, SAO VALIDOS!


#----------------------------------------------------------------------------------
# MSBuffer is the main class, in which the toolbox is initialized and runs

class MSBuffer(object):
    
    # Initializing parameters
    def __init__(self,UCs,inputmap_name,variable_interest,OutPutFolder,escale,mult,OutPutTxt,feature_to_count,count_on_off,inputCol):
	
	self.inpuCol=inputCol #alsdjaslkjdslakj
	self.list_buffer_scales=[]
	self.scale=escale
	self.mult=mult
	self.OutPutTxt=OutPutTxt
	self.lista_erases=[]
	self.isArea=''
	self.isPoint=''
        self.UCs=UCs
	self.inputmap_name=inputmap_name
        self.variable_interest=variable_interest
        self.OutPutFolder=OutPutFolder
        self.listbuffers='' # List of buffer map names generated by createBuffer function
	self.Listerase='' # List of donut buffer map names generated by erase function
	self.listclip='' # List of maps with the variable of interest clipped by donut buffer maps, generated by clip_variable_interest_by_donut_buffer function
	self.FieldList=[]
	self.cout=0
	#self.feature=feature_to_count # = variable of interest, i.e, the shapefile whose features should be counted
	self.count_on_off=count_on_off
	self.countList=[]
	self.listaAreaFeatures=[]
	self.referenceListquery=[]
	self.listAreaAnalise=[]
	self.txtAreaAnalise=''
	self.txtFuncarea=''
	self.ListIDcod=[]
	self.txtCountFeat=''

        self.lista='' # para usar na def selectINlist
        self.pattern='' # para usar na def selectINlist
	
    # 
    def DefineEscale(self):
	'''
	Function DefineScale
	
	This function reads the scale (buffer size) and mutiplier (number of buffers) parameters 
	and defines a list of buffer sizes
	'''
	
	con_esc=self.scale 
	for i in range(self.mult):	
		self.list_buffer_scales.append(con_esc) #criando lista de escala
		con_esc=con_esc+self.scale # Defining new buffer value
		
    # Creates a list of features (ID, names, ...) given the input map and the identificator column
    # each component of this list corresponds to a feature of the input map
    def CreateListaFieldReference(self):
	with arcpy.da.SearchCursor(self.UCs, self.inpuCol) as cursor:
	    for row in cursor:
		try:
		    temp=int(row[0])
		    self.ListIDcod.append(temp)
		    query="\""+self.inpuCol+"\"="+`temp`
		    self.referenceListquery.append(query)
		except:
		    self.ListIDcod.append(row[0])
		    query =  self.inpuCol+"='%s'" % row[0]
		    self.referenceListquery.append(query)
		    
		
		    
    # This function deletes pre-existing shape files in the output geodatabase
    def deletefiles(self):
	if os.path.exists(self.OutPutFolder+'/'+geoDB_name):
	    arcpy.env.workspace=self.OutPutFolder+'/'+geoDB_name
	    lista=arcpy.ListFeatureClasses()
	    for i in lista:
		inp=i.replace(".shp",'')
		arcpy.Delete_management(i)
		arcpy.Delete_management(inp)
    
    # This function looks into a list (self.lista), search for elements that match the string self.pattern, and returns 
    # the list of matched elements
    def selecInList(self):
        lista=[]
        for i in self.lista:
            if self.pattern in i:
                lista.append(i)
        return lista
        
    # In case the geodatabase does not exist, this function creates it
    def createDb(self):
        if not os.path.exists(self.OutPutFolder+'/'+geoDB_name):
            arcpy.CreateFileGDB_management(self.OutPutFolder,geoDB_name)
        
    # This function generates buffer maps (which overlap the input map)
    # It also defines a list of buffer map names called self.listbuffers
    def createBuffer(self):
        arcpy.env.workspace=self.OutPutFolder+'/'+geoDB_name
        for i in self.list_buffer_scales:
            formatName="00000"+`i`
            formatName=formatName[-5:] # MAXIMUM BUFFER SIZE = 99999
	    #self.inputmap_name=self.inputmap_name.replace(".shp",'')
            OutPutName=self.inputmap_name+"_buffer_with_inputmap_"+formatName
            arcpy.Buffer_analysis(self.UCs, OutPutName, i, "FULL", "FLAT", "ALL")
	listbuffers=arcpy.ListFeatureClasses()
	self.lista=listbuffers
	self.pattern="_buffer_with_inputmap_"
	self.listbuffers=MSBuffer.selecInList(self)	
    
    
    # This function erases the original input feature from the buffer map, resulting in a donut-like buffer
    # It also defines a list of donut buffer map names called self.Listerase 
    def erase(self):
	for i in self.listbuffers:
	    out_name=i.replace("buffer_with_inputmap", "donut_buffer")
	    arcpy.Erase_analysis(i, self.UCs, out_name, '')   
	    self.lista_erases.append(out_name)
	Listerase=arcpy.ListFeatureClasses()
	self.lista=Listerase
	self.pattern="_donut_buffer_"
	self.Listerase=MSBuffer.selecInList(self)
	
	
    # This function checks the geometry type of the variable of interest (Polygon, Point) (pode Polyline ou outros????)
    # This is written in a global variable (self.isArea or self.isPoint)
    ################ PORQUE ELE CALCULA A AREA EM HA DE CADA POLIGONO DO MAPA DA VARIAVEL DE INTERESSE TODO?
    ##### EH para definir a area funcional depois?
    def typeFeature(self): # erro aqui!!!!!
	desc = arcpy.Describe(self.variable_interest) # error na arcpy.Describe = IOError: "" does not exist
	geometryType = desc.shapeType
	if geometryType == 'Polygon':
	    self.isArea=True # vendo se eh um poligono ou nao se nao for sera ponto
	    try:
		arcpy.AddField_management(self.variable_interest, "area_ha", "DOUBLE", 10, 10)
		arcpy.CalculateField_management(self.variable_interest,"area_ha","!shape.area@squaremeters!","PYTHON_9.3","#")
		expression="!Area_ha!/10000" # Area_ha ou area_ha? "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
		arcpy.CalculateField_management(self.variable_interest,"area_ha",expression,"PYTHON_9.3","#")		
	    except Exception as e:
		pass
	else:
	    self.isPoint=True # neste cado eh um ponto
	
    
	    
	
    def count_Features(self):
	if self.isArea:
	    
	    for erase in self.lista_erases:
		arcpy.SelectLayerByLocation_management(self.variable_interest, "INTERSECT", erase) # para calcular functional area??????????????
		cursor = arcpy.da.SearchCursor(self.variable_interest, ['FID'])
		count=0
		for i in cursor:
		    count=count+1
		self.countList.append(count)
		# count = len(cursor) ??
		
		with arcpy.da.SearchCursor(self.variable_interest, "area_ha") as cursor: # functional area
		    summed_total=0
		    for row in cursor:
			    summed_total = summed_total + row[0]
		    summed_total=round(summed_total, ndigits=2)
		    self.listaAreaFeatures.append(summed_total) #### O QUE EH ISSO?!!
			
	if self.isPoint:
	    
	    for erase in self.lista_erases:
		arcpy.SelectLayerByLocation_management(self.variable_interest,"INTERSECT",erase)
		cursor = arcpy.da.SearchCursor(self.variable_interest, ['FID'])
		count=0
		for i in cursor:
		    count=count+1
		self.countList.append(count)	    
	    
		
		
    # This function clips the map of the variable of interest inside the donut buffer area
    # It also defines a list of names of variable of interest map inside the donut buffer, called self.listclip 	
    def clip_variable_interest_by_donut_buffer(self):
	for i in self.Listerase:
	    out_name=i.replace("donut_buffer", "variable_interest_inside_donut_buffer")
	    arcpy.Clip_analysis(self.variable_interest, i, out_name, "")
	    
	    Listclip=arcpy.ListFeatureClasses()
	    self.lista=Listclip
	    self.pattern="_variable_interest_inside_donut_buffer_"
	    self.listclip=MSBuffer.selecInList(self)	    
	    
    # Resturn a list of fields (columns) of a map
    def checkField(self,mapa):
	fields = arcpy.ListFields(mapa)
	for field in fields:
	    self.FieldList.append(field.name)	
	return self.FieldList
    
    # deletes the field area_ha from the clip
    def deletefield(self):
	for i in self.listclip:
	    fields=MSBuffer.checkField(self, i)
	    if "Area_ha" in fields:
		arcpy.DeleteField_management(i, ["Area_ha"])    
    
    # add/calculates the field area_ha again inside the clip
    def addfield(self):
	for i in self.listclip:
	    try:
		arcpy.AddField_management(i, "Area_ha", "DOUBLE", 10, 10)
		arcpy.CalculateField_management(i,"Area_ha","!shape.area@squaremeters!","PYTHON_9.3","#")
		expression="!Area_ha!/10000"
		arcpy.CalculateField_management(i,"Area_ha",expression,"PYTHON_9.3","#")
	    except:
		print "pass"
    
    # calculates areas of clip maps
    
    
    
    def calculateAreaAnalises(self):
	for i in self.listclip:
	    summed_total =0 
	    with arcpy.da.SearchCursor(i, "Shape_Area") as cursor:
		for row in cursor:
		    summed_total = summed_total + row[0]
		summed_total=round(summed_total, ndigits=2)
		summed_total=summed_total/10000
		self.listAreaAnalise.append(summed_total)

    def removeDuplicateList(self,lista):
	listaapoio=[]
	for i in lista:
	    if not i in listaapoio:
		listaapoio.append(i)
	
	return listaapoio
	    
	
    def criatxtArea_Analise(self):
	idcod=str(self.ListIDcod[self.cout])
	
	
	
	##----------------TXTAREAAnalise------------------------------------------------------
	#self.listAreaAnalise=MSBuffer.removeDuplicateList(self, self.listAreaAnalise)
	self.txtAreaAnalise.write(idcod+','+','.join(str(x) for x in self.listAreaAnalise))
	self.txtAreaAnalise.write('\n')
	self.listAreaAnalise=[]
	#-------------------------------------------------------------------------------------
	
	if self.isArea==True:
	    self.listaAreaFeatures=MSBuffer.removeDuplicateList(self, self.listaAreaFeatures)
	    ##----------------TXTFunarea------------------------------------------------------
	    self.txtFuncarea.write(idcod+','+','.join(str(x) for x in self.listaAreaFeatures))
	    self.txtFuncarea.write('\n')
	    self.listaAreaFeatures=[]
	    #-------------------------------------------------------------------------------------	
	
	
	if self.count_on_off:
	    
	    self.countList=MSBuffer.removeDuplicateList(self, self.countList)
	    self.txtCountFeat.write(idcod+','+','.join(str(x) for x in self.countList))
	    self.txtCountFeat.write('\n')
	    self.countList=[]		
		
	    #-------------------------------------------------------------------------------------		
	
	
	
			    
		
			
	

	
	
	
	
	
	
class principal(MSBuffer):
    def __init__(self, UCs, inputmap_name, variable_interest, OutPutFolder, escale, mult, 
                OutPutTxt, feature_to_count, count_on_off, inputCol):
	MSBuffer.__init__(self, UCs, inputmap_name, variable_interest, OutPutFolder, escale, mult, 
	                  OutPutTxt, feature_to_count, count_on_off, 
	                  inputCol)
    
    
		
		
    def run(self):
	
	

	MSBuffer.typeFeature(self)	# parece ter ERRO AQUI!!!    
	
	MSBuffer.CreateListaFieldReference(self)
	MSBuffer.DefineEscale(self) #definindo a lista de escalas
	MSBuffer.createDb(self)
	
	#area analises
	os.chdir(OutPutFolder)
	
	self.txtAreaAnalise=open("__AreaAnalises_"+self.OutPutTxt+".txt",'w')
	self.txtAreaAnalise.write(self.inpuCol+','+','.join(str(x) for x in self.list_buffer_scales)) #cabecalho
	self.txtAreaAnalise.write('\n')
	#--------
	
	#Fuctional area
	if self.isArea:
	    self.txtFuncarea=open("__FunctionalArea"+self.OutPutTxt+".txt",'w')
	    self.txtFuncarea.write(self.inpuCol+','+','.join(str(x) for x in self.list_buffer_scales)) #cabecalho
	    self.txtFuncarea.write('\n')	
	
	if self.count_on_off:
	    #Fuctional area
	    self.txtCountFeat=open("__CountFeatures_"+self.OutPutTxt+".txt",'w')
	    self.txtCountFeat.write(self.inpuCol+','+','.join(str(x) for x in self.list_buffer_scales)) #cabecalho
	    self.txtCountFeat.write('\n')	    
	
	self.cout=0
	
	for i in self.referenceListquery:
	    if overwrite_maps == True:
		MSBuffer.deletefiles(self) ###### colocar if overwrite = True
		
	    arcpy.SelectLayerByAttribute_management(self.UCs,"NEW_SELECTION",i)
	    MSBuffer.createBuffer(self)
	    MSBuffer.erase(self)
	    MSBuffer.count_Features(self)
	    MSBuffer.clip_variable_interest_by_donut_buffer(self)
	    MSBuffer.deletefield(self)
	    MSBuffer.addfield(self)
	    MSBuffer.calculateAreaAnalises(self)
	    MSBuffer.criatxtArea_Analise(self)
	
	    
	    
	    self.cout=self.cout+1
	self.txtAreaAnalise.close()
	
	if self.isArea:
	    self.txtFuncarea.close()
	if self.isPoint:
	    self.txtCountFeat.close()
	    
		    
	
fun=principal(UCs, inputmap_name, variable_interest, OutPutFolder, escale, mult, OutPutTxt, 
             feature_to_count, count_on_off, inputCol)
fun.run()
