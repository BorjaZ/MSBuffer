#---------------------------------------------------------------------------------------
"""
 MSbuffer - MultiScale Buffer Analysis

 Bruno P. Leles - brunopleles@gmail.com
 John W. Ribeiro - jw.ribeiro.rc@gmail.com
 Juliana Silviera dos Santos - 
 Camila Eboli - 
 Alice C. Hughes - 
 Bernardo B. S. Niebuhr - bernardo_brandaum@yahoo.com.br
 Milton C. Ribeiro - mcr@rc.unesp.br

 Universidade Estadual Paulista - UNESP
 Rio Claro - SP - Brasil

 This script runs inside ArcMap v. 10.2.1 using Python shell.
 Usage: ????

 Short description

 Copyright (C) 2017 by Bruno P. Leles, John W. Ribeiro, and Milton C. Ribeiro.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 2 of the license, 
 or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program. If not, see <http://www.gnu.org/licenses/>.
"""
#---------------------------------------------------------------------------------------

#------------------------------
# Import modules 
import arcpy
from arcpy import env
import os, sys
import arcpy.mapping

#------------------------------
# Name of the geo database where output buffer maps will be saved
geoDB_name = "output_buffer_maps.gdb"
# Do we want to overwrite output buffer maps in case the analysis is re-run?
overwrite_maps = True

#------------------------------
# Reading parameters from the GUI

# Input map
inputmap = arcpy.GetParameterAsText(0) # input map
inputCol = arcpy.GetParameterAsText(1) # column of the input map, correspondent to the variable of interest
inputmap_name = inputmap.split("\\") # extracting the name of the input map
inputmap_name = inputmap_name[-1].replace(".shp",'') # name of the input map (without the path)

# Input variable of interest
variables_interest = arcpy.GetParameterAsText(2) # map of the variable of interest
variable_interest_list = variables_interest.split(';')

# Scale (buffer size in meters)
scale = arcpy.GetParameterAsText(3)
scale = int(scale)

# Number of buffers
nbuffers = arcpy.GetParameterAsText(4)
nbuffers = int(nbuffers)

# Should we count the number of features?
count_on_off = arcpy.GetParameterAsText(5) # boolean to count features
#feature_to_count = variable_interest

# Should we calculate Functional Area?
func_area_on_off = arcpy.GetParameterAsText(6) # boolean to calculat functional area

# Prefix for output files 
OutPutTxt = arcpy.GetParameterAsText(7)

# DEFINIR NOMES DOS OUTPUT MAPS (GEODB)

# Folder for output files
OutPutFolder = arcpy.GetParameterAsText(8)

# PODEMOS TESTAR SE OS PARAMETROS ESTAO OK, SAO VALIDOS!


#----------------------------------------------------------------------------------
# MSBuffer is the main class, in which the toolbox is initialized and runs

class MSBuffer(object):
    
    # Initializing parameters
    def __init__(self, inputmap, inputmap_name, inputCol, variable_interest_list, OutPutTxt, OutPutFolder,
                 scale, nbuffers, count_on_off, func_area_on_off):	
	
	# Input maps and outputs
	self.inputmap = inputmap # Input map
	self.inputmap_name = inputmap_name # Name of the input map
	self.inpuCol = inputCol # column of the input map that identifies the ID of the polygons around which the buffers will be drawn	
	self.variable_interest_list = variable_interest_list # List of maps correspondent to the variables of interest
	self.OutPutTxt = OutPutTxt # Prefix of the output file names
	self.OutPutFolder = OutPutFolder # Folder where text files will be saved
	
	# Parameters
	self.scale = scale
	self.nbuffers = nbuffers
	self.count_on_off = count_on_off
	self.func_area_on_off = func_area_on_off
	
	# Auxiliary variables
	self.isArea=''
	self.isPoint=''
        
        self.listbuffers='' # List of buffer map names (with input map) generated by createBuffer function
	self.Listerased='' # List of donut buffer map names (buffer without input mao) generated by erase function
	self.listclip='' # List of maps with the variable of interest clipped by donut buffer maps, generated by clip_variable_interest_by_donut_buffer function
	
	self.list_buffer_scales=[] # list of buffer sizes (e.g., 500, 1000, 1500, 2000)
	self.ListIDcod=[]
	self.FieldList=[]
	self.countList=[]
	self.listaAreaFeatures=[]
	self.referenceListquery=[]
	self.listAreaAnalise=[]	
	
	self.counter = 0 # Counter to identify the elements of the polygon ID list
	self.onelist='' # para usar na def selectINlist
	self.pattern='' # para usar na def selectINlist		
	
	#self.feature=feature_to_count # = variable of interest, i.e, the shapefile whose features should be counted

	# Output files and names
	self.txtArea = '' # Output file where area analysis will be saved
	self.txtFuncArea = '' # Output file where functional area analysis will be saved
	self.txtCountFeat = '' # Output file where cont feature analysis will be saved
	
	self.txtArea_name_list = []
	self.txtFuncArea_name_list = []
	self.txtCountFeat_name_list = []
	for var in variable_interest_list:
	    self.variable_interest_name = var.split("\\")
	    self.variable_interest_name = self.variable_interest_name[-1].replace(".shp",'') # name of the input map (without the path)	
	    # Names of the output files
	    # Area
	    self.txtArea_name_list.append(self.OutPutTxt+'_'+self.variable_interest_name+"_Area.txt")
	    # Functional area
	    self.txtFuncArea_name_list.append(self.OutPutTxt+'_'+self.variable_interest_name+"_FunctionalArea.txt")
	    # Count feaures
	    self.txtCountFeat_name_list.append(self.OutPutTxt+'_'+self.variable_interest_name+"_Count.txt")
	
    #------------------------
    def DefineScale(self):
	'''
	Function DefineScale
	
	This function reads the scale (buffer size) and the number of buffers parameters 
	and defines a list of buffer sizes
	'''
	
	con_esc=self.scale 
	for i in range(self.nbuffers):	
		self.list_buffer_scales.append(con_esc) #criando lista de escala
		con_esc=con_esc+self.scale # Defining new buffer value
		
    # Creates a list of features (ID, names, ...) given the input map and the identificator column
    # each component of this list corresponds to a feature of the input map
    def CreateInputMapIDList(self):
	with arcpy.da.SearchCursor(self.inputmap, self.inpuCol) as cursor:
	    for row in cursor:
		try:
		    temp=int(row[0])
		    self.ListIDcod.append(temp)
		    query="\""+self.inpuCol+"\"="+`temp`
		    self.referenceListquery.append(query)
		except:
		    self.ListIDcod.append(row[0])
		    query =  self.inpuCol+"='%s'" % row[0]
		    self.referenceListquery.append(query)
		    
		    	    
    # This function deletes pre-existing shape files in the output geodatabase
    def deletefiles(self):
	if os.path.exists(self.OutPutFolder+'/'+geoDB_name):
	    arcpy.env.workspace=self.OutPutFolder+'/'+geoDB_name
	    onelist=arcpy.ListFeatureClasses()
	    for i in onelist:
		inp=i.replace(".shp",'')
		arcpy.Delete_management(i)
		arcpy.Delete_management(inp)
    
    # This function looks into a list (self.onelist), search for elements that match the string self.pattern, and returns 
    # the list of matched elements
    def selecInList(self):
        onelist=[]
        for i in self.onelist:
            if self.pattern in i:
                onelist.append(i)
        return onelist
        
    # In case the geodatabase does not exist, this function creates it
    def createDb(self):
        if not os.path.exists(self.OutPutFolder+'/'+geoDB_name):
            arcpy.CreateFileGDB_management(self.OutPutFolder, geoDB_name)
        
    # This function generates buffer maps (which overlap the input map)
    # It also defines a list of buffer map names called self.listbuffers
    def createBuffer(self):
        arcpy.env.workspace=self.OutPutFolder+'/'+geoDB_name
        for i in self.list_buffer_scales:
            formatName="00000"+`i`
            formatName=formatName[-5:] # MAXIMUM BUFFER SIZE = 99999
	    #self.inputmap_name=self.inputmap_name.replace(".shp",'')
            OutPutName=self.inputmap_name+"_buffer_with_inputmap_"+formatName
            arcpy.Buffer_analysis(self.inputmap, OutPutName, i, "FULL", "FLAT", "ALL")
	listbuffers=arcpy.ListFeatureClasses()
	self.onelist=listbuffers
	self.pattern="_buffer_with_inputmap_"
	self.listbuffers=MSBuffer.selecInList(self)	
    
    # This function erases the original input feature from the buffer map, resulting in a donut-like buffer
    # It also defines a list of donut buffer map names called self.Listerased 
    def erase(self):
	for i in self.listbuffers:
	    out_name=i.replace("buffer_with_inputmap", "donut_buffer")
	    arcpy.Erase_analysis(i, self.inputmap, out_name, '')   
	    #self.lista_erases.append(out_name)
	Listerased=arcpy.ListFeatureClasses()
	self.onelist=Listerased
	self.pattern="_donut_buffer_"
	self.Listerased=MSBuffer.selecInList(self)
	
    # This function checks the geometry type of the variable of interest (Polygon, Point) (pode Polyline ou outros????)
    # This is written in a global variable (self.isArea or self.isPoint)
    ################ PORQUE ELE CALCULA A AREA EM HA DE CADA POLIGONO DO MAPA DA VARIAVEL DE INTERESSE TODO?
    ##### EH para definir a area funcional depois?
    def typeFeature(self): # erro aqui!!!!!
	desc = arcpy.Describe(self.variable_interest) # error na arcpy.Describe = IOError: "" does not exist
	geometryType = desc.shapeType
	if geometryType == 'Polygon':
	    self.isArea = True # vendo se eh um poligono ou nao se nao for sera ponto
	    try:
		arcpy.AddField_management(self.variable_interest, "area_ha", "DOUBLE", 10, 10)
		arcpy.CalculateField_management(self.variable_interest, "area_ha", "!shape.area@hectares!","PYTHON_9.3","#")
		#arcpy.CalculateField_management(self.variable_interest, "area_ha", "!shape.area@squaremeters!","PYTHON_9.3","#")
		#expression="!Area_ha!/10000" # Area_ha ou area_ha? "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
		#arcpy.CalculateField_management(self.variable_interest,"area_ha",expression,"PYTHON_9.3","#")		
	    except Exception as e:
		pass
	elif geometryType == 'Point' or geometryType == 'Multipoint':
	    self.isPoint = True # neste cado eh um ponto
	# what about lines?
	
	
    def count_Features(self):
	
	for donut in self.Listerased:
	    arcpy.SelectLayerByLocation_management(self.variable_interest, "INTERSECT", donut) # para calcular functional area??????????????
	    cursor = arcpy.da.SearchCursor(self.variable_interest, ['FID'])
	    count = 0
	    for i in cursor:
		count = count+1
	    self.countList.append(count)	  	    
		
		
			
    def calc_FuncArea(self):
				
	for donut in self.Listerased:
	    arcpy.SelectLayerByLocation_management(self.variable_interest, "INTERSECT", donut) # para calcular functional area??????????????
	    cursor = arcpy.da.SearchCursor(self.variable_interest, ['FID'])

	    with arcpy.da.SearchCursor(self.variable_interest, "area_ha") as cursor: # functional area
		summed_total=0
	    for row in cursor:
		summed_total = summed_total + row[0]
	    summed_total = round(summed_total, ndigits=2)
	    self.listaAreaFeatures.append(summed_total) #### O QUE EH ISSO?!!    		
   
	
    # This function clips the map of the variable of interest inside the donut buffer area
    # It also defines a list of names of variable of interest map inside the donut buffer, called self.listclip 	
    def clip_variable_interest_by_donut_buffer(self):
	for i in self.Listerased:
	    out_name=i.replace("donut_buffer", "variable_interest_inside_donut_buffer")
	    arcpy.Clip_analysis(self.variable_interest, i, out_name, "")
	    
	    Listclip=arcpy.ListFeatureClasses()
	    self.onelist=Listclip
	    self.pattern="_variable_interest_inside_donut_buffer_"
	    self.listclip=MSBuffer.selecInList(self)	    
	    
    # Resturn a list of fields (columns) of a map
    def checkField(self,mapa):
	fields = arcpy.ListFields(mapa)
	for field in fields:
	    self.FieldList.append(field.name)	
	return self.FieldList
    
    # deletes the field area_ha from the clip
    def deletefield(self):
	for i in self.listclip:
	    fields=MSBuffer.checkField(self, i)
	    if "Area_ha" in fields:
		arcpy.DeleteField_management(i, ["Area_ha"])    
    
    # add/calculates the field area_ha again inside the clip
    def addfield(self):
	for i in self.listclip:
	    try:
		arcpy.AddField_management(i, "Area_ha", "DOUBLE", 10, 10)
		arcpy.CalculateField_management(i,"Area_ha","!shape.area@squaremeters!","PYTHON_9.3","#")
		expression="!Area_ha!/10000"
		arcpy.CalculateField_management(i,"Area_ha",expression,"PYTHON_9.3","#")
	    except:
		print "pass"
    
    # calculates areas of clip maps
    
    
    
    def calculateAreaAnalises(self):
	for i in self.listclip:
	    summed_total =0 
	    with arcpy.da.SearchCursor(i, "Shape_Area") as cursor:
		for row in cursor:
		    summed_total = summed_total + row[0]
		summed_total=round(summed_total, ndigits=2)
		summed_total=summed_total/10000
		self.listAreaAnalise.append(summed_total)

    def removeDuplicateList(self,onelist):
	onelistapoio=[]
	for i in onelist:
	    if not i in onelistapoio:
		onelistapoio.append(i)
	
	return onelistapoio
	    
    # Create output header
    def output_header(self):
	
	# Change to output folder
	os.chdir(self.OutPutFolder)
    
	# Initialize output text file for area analysis
    
	# Area
	if self.isArea:
	    self.txtArea=open(self.txtArea_name_list[self.counter], 'w')
	    self.txtArea.write(self.inpuCol+','+','.join(str(x) for x in self.list_buffer_scales)) # File header
	    self.txtArea.write('\n')
	    self.txtArea.close()
    
	# Functional area
	if self.isArea and func_area_on_off:
	    self.txtFuncArea=open(self.txtFuncArea_name_list[self.counter], 'w')
	    self.txtFuncArea.write(self.inpuCol+','+','.join(str(x) for x in self.list_buffer_scales)) # File header
	    self.txtFuncArea.write('\n')
	    self.txtFuncArea.close()
    
	# Count feaures
	if self.count_on_off:
	    self.txtCountFeat=open(self.txtCountFeat_name_list[self.counter], 'w')
	    self.txtCountFeat.write(self.inpuCol+','+','.join(str(x) for x in self.list_buffer_scales)) # File header
	    self.txtCountFeat.write('\n')
	    self.txtCountFeat.close()
	    
    # This function writes output information in the output text files
    def create_txt_outputs(self):
	# Polygon ID info
	idcod = str(self.ListIDcod[self.counter])
    
	# Change to output folder
	os.chdir(self.OutPutFolder)	
	
	##----------------txtArea------------------------------------------------------
	#self.listAreaAnalise=MSBuffer.removeDuplicateList(self, self.listAreaAnalise)
	if self.isArea:
	    self.txtArea=open(self.txtArea_name_list[self.counter_variables], 'a')
	    self.txtArea.write(idcod+','+','.join(str(x) for x in self.listAreaAnalise))
	    self.txtArea.write('\n')
	    self.txtArea.close()	
	    self.listAreaAnalise=[]
	
	if self.isArea and func_area_on_off:
	    self.listaAreaFeatures=MSBuffer.removeDuplicateList(self, self.listaAreaFeatures)
	    ##----------------TXTFunarea------------------------------------------------------
	    self.txtFuncArea=open(self.txtFuncArea_name_list[self.counter_variables], 'a')    
	    self.txtFuncArea.write(idcod+','+','.join(str(x) for x in self.listaAreaFeatures))
	    self.txtFuncArea.write('\n')
	    self.txtFuncArea.close()	    
	    self.listaAreaFeatures=[]	
		
	if self.count_on_off:
	    self.countList=MSBuffer.removeDuplicateList(self, self.countList)
	    self.txtCountFeat=open(self.txtCountFeat_name_list[self.counter_variables], 'a')
	    self.txtCountFeat.write(idcod+','+','.join(str(x) for x in self.countList))
	    self.txtCountFeat.write('\n')
	    self.txtCountFeat.close()		    
	    self.countList=[]		

	

	
class principal(MSBuffer):
    def __init__(self, inputmap, inputmap_name, inputCol, variable_interest_list, OutPutTxt, OutPutFolder,
                 scale, nbuffers, count_on_off, func_area_on_off):
	
	MSBuffer.__init__(self, inputmap, inputmap_name, inputCol, variable_interest_list, OutPutTxt, OutPutFolder,
                 scale, nbuffers, count_on_off, func_area_on_off)
	
	# Clear selection of features
	arcpy.SelectLayerByAttribute_management(self.inputmap, "CLEAR_SELECTION")	
    	
    # Here we run everything!
    def run(self):
 
	# Create the list of polygon IDs, from the input map
	MSBuffer.CreateInputMapIDList(self)
	# Define the list of buffer sizes
	MSBuffer.DefineScale(self)
	# If the Geodatabase does not exist, create it
	MSBuffer.createDb(self)
	
	# Create output files and write headers for each variable of interest
	self.counter=0
	for var_interest in self.variable_interest_list:
	    self.variable_interest = var_interest
			
	    # Define the geometry of the variable of interest
	    MSBuffer.typeFeature(self)	# parece ter ERRO AQUI!!!   		
			
	    # Create output files and write headers
	    MSBuffer.output_header(self)
	    
	    self.counter = self.counter + 1
	
	# Analyses
	    	    
	# Initializing counter for getting polygon ID
	self.counter=0	
	
	for i in self.referenceListquery:
	    if overwrite_maps == True:
		MSBuffer.deletefiles(self) ###### colocar if overwrite = True
		
	    arcpy.SelectLayerByAttribute_management(self.inputmap, "NEW_SELECTION", i)
	    MSBuffer.createBuffer(self)
	    MSBuffer.erase(self)
	    
	    print "olaaaaa"
	    
	    self.counter_variables = 0
	    for var_interest in self.variable_interest_list:
		self.variable_interest = var_interest
		
		# Define the geometry of the variable of interest
		MSBuffer.typeFeature(self)	# parece ter ERRO AQUI!!!
	    
		# Count features
		if self.count_on_off:
		    MSBuffer.count_Features(self)
		# Calculate Functional Area
		if self.isArea and self.func_area_on_off:
		    MSBuffer.calc_FuncArea(self)	    
	    
		# Calculate Area
		if self.isArea:
		    MSBuffer.clip_variable_interest_by_donut_buffer(self)
		    MSBuffer.deletefield(self)
		    MSBuffer.addfield(self)
		    MSBuffer.calculateAreaAnalises(self)
		
		# Write outputs
		MSBuffer.create_txt_outputs(self)
		
		self.counter_variables += 1
	    
	    # Next polygon
	    self.counter=self.counter+1
	
	# Clear selection
	arcpy.SelectLayerByAttribute_management(self.inputmap, "CLEAR_SELECTION")
	
	    
		    
	
fun=principal(inputmap, inputmap_name, inputCol, variable_interest_list, OutPutTxt, OutPutFolder,
                 scale, nbuffers, count_on_off, func_area_on_off)
fun.run()
